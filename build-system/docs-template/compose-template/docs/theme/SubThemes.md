---
title: Подтемы. Инверсия цветов.
---

Подтемы позволяют локально переопределять цветовые токены, когда блок интерфейса рисуется на фоне с другой «яркостью» или контрастом, чем основной экран.

В SDDS для этого есть три подтемы:

- `{{ docs-theme-codeReference }}.OnLight { … }`
- `{{ docs-theme-codeReference }}.OnDark { … }`
- `{{ docs-theme-codeReference }}.Inverse { … }`

Ниже описано, чем они отличаются и когда какую использовать.

## Общие принципы

- На уровне приложения/экрана всегда используйте **базовую тему**:
  ```kotlin
  {{ docs-theme-codeReference }} {
      // контент приложения/экрана
  }
  ```
- Подтемы применяйте **точечно** — вокруг блока, который визуально «живет» на другом фоне:
  - внутри светлой карты на общем тёмном экране,
  - внутри тёмного баннера на светлом экране,
  - внутри акцентного/промо‑блока с заливкой бренд‑цветом.

Таким образом, компоненты внутри подтемы получают корректные `text*`, `surface*`, `outline*` токены для своего локального контекста, без ручного подбора цветов.

## `{{ docs-theme-codeReference }}.OnLight`

Подтема для блоков, которые расположены **на светлом фоне**: белом, близком к нему светлом сером и т.п.

Используйте, когда:

- Основной экран может быть тёмным, но отдельный блок всегда светлый  
  (например, карточка с белой заливкой, bottom sheet, модальное «окно»).
- Вы хотите гарантировать, что внутри блока будут использоваться цвета как для текста/поверхностей **на светлом фоне**, независимо от системной темы.

### Пример: белая секция в тёмной теме

```kotlin

@Composable
fun OnLightExample() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            // Темный фон в темной теме
            .background({{ docs-theme-codeReference }}.colors.backgroundDefaultPrimary),
    ) {
      Box(
            modifier = Modifier
                .fillMaxWidth()
                // секция всегда светлая
                .background(Color.White),
        ) {
            {{ docs-theme-codeReference }}.OnLight {
                // Кнопка, которая в темной теме была, например, белая, 
                // в OnLight подтеме автоматически станет, например, черная
                Button(label = "label", style = BasicButton.M.Default.style())
            }
        }
    }
}
```

## `{{ docs-theme-codeReference }}.OnDark`

Подтема для блоков, которые расположены **на тёмном фоне**: почти чёрном, тёмно‑сером, затемнённом фото и т.п.

Используйте, когда:

- Основной экран может быть светлым, но отдельный блок всегда тёмный  
  (например, видео‑плеер, промо‑баннер с тёмной заливкой, оверлей поверх контента).
- Нужно гарантировать корректный контраст текста и контролов именно **на тёмном фоне**.

### Пример: тёмная секция в светлой теме

```kotlin
@Composable
fun OnDarkExample() {
    {{ docs-theme-codeReference }}.Default {
        // общий светлый экран
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background({{ docs-theme-codeReference }}.colors.backgroundPrimary),
        ) {
            Column {
                Text("Обычный контент экрана")

                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        // секция всегда черная
                        .background(Color.Black),
                ) {
                    {{ docs-theme-codeReference }}.OnDark {
                        Button(label = "label", style = BasicButton.M.Default.style())
                    }
                }
            }
        }
    }
}
```

Компоненты внутри `OnDark` автоматически используют «на тёмном» токены и корректные состояния (hover/pressed и т.д.).

## `{{ docs-theme-codeReference }}.Inverse`

Подтема **инверсии**: она «меняет местами» семантику `Default` и `Inverse` токенов.

Это полезно, когда:

- Блок целиком должен выглядеть как «инверсный» относительно остального экрана:
  - тёмная карточка на светлом экране,
  - светлый блок внутри тёмного экрана,
  - акцентный/брендовый баннер, где все компоненты должны вести себя как на противоположной палитре.
- Вы хотите, чтобы внутри блока:
  - фон использовал `backgroundInverse*`/`surfaceInverse*`,
  - текст и иконки — `textInverse*`,
  - но при этом сохранялась корректная связка всех семантических токенов.

### Пример: инверсная секция

```kotlin
@Composable
fun InverseSectionExample() {
    Column(Modifier.fillMaxSize()) {
        // обычный контент в светлой теме
        Text(text = "Обычный блок")


        Box(
            modifier = Modifier
                .fillMaxWidth()
                // Инвертированный темный фон
                .background(...),
        ) {
            // инверсный блок
            {{ docs-theme-codeReference }}.Inverse {
                Column {
                    // Кнопка инвертирует свои цвета: например, в светлой теме кнопка была темной, но на темном фоне 
                    // с инвертированной подтемой стала светлой.
                    Button(label = "label", style = BasicButton.M.Default.style())
                }
            }
        }
    }
}
```

`Inverse` удобно использовать для крупных секций, которые визуально должны «перевернуть» палитру относительно остальной страницы.

## Когда какую подтему выбирать

Ориентируйтесь на **фон, на котором реально рисуется контент внутри блока**, а не только на системную тему:

- Блок на **явно светлом** фоне → `OnLight`
- Блок на **явно тёмном** фоне → `OnDark`
- Блок должен выглядеть как «обратная» версия основной темы экрана → `Inverse`

При этом:

- Подтемы можно вкладывать, но не стоит строить длинные цепочки — старайтесь ограничиваться 1–2 уровнями.
- Подтема применяется ко **всем дочерним** composable внутри её лямбды.
- Внутри подтемы всегда используйте стандартные SDDS‑компоненты и токены (`{{ docs-theme-codeReference }}.colors.*`, `{{ docs-theme-codeReference }}.gradients.*`) — они уже настроены под выбранную подтему.